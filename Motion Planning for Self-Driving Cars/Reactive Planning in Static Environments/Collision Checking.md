# Collision Checking

## Collision Checking Challenges

* Computationally intensive
* Requires perfect information to guarantee I safety
* Needs to be approximated, and must be robust to noise

## Swath Computation

<img alt="Swath Computation" src="./Swath Computation.png" style="height:30vh;margin: 1em auto; display:block;"/>

* Area occupied by car along path generated by rotating the car's footprint by each $x, y,\theta$ along the path
* Swath along path is the union of each rotated and translated footprint
* Swath can then be checked for collisions

$$S=\cup_{p\in P}F\left(x\left(p\right),y\left(p\right),\theta\left(p\right) \right)$$

### Discretized Example

<img alt="Initial state" src="./Initial state.jpg" style="height:30vh;margin: 1em auto; display:block;"/>

* Initial state of the vehicle in the occupancy grid, with base link at the origin
* Will need to rotate and translate to get the new footprint at point $(1.0, 2.0, \frac{\pi}{2})$

1. First, rotate the footprint about the
origin by $\frac{\pi}{2}$
2. Next, translate each point by $(1.0, 2.0)$

<img alt="Second state" src="./Second state.jpg" style="height:30vh;margin: 1em auto; display:block;"/>

* To compute the occupancy grid index for each point in the footprint, add half the width/height of the occupancy grid, and divide by the grid resolution $\delta$
* Swath is then the union of these indices

$$x_i=\frac{x(p)+\frac{X}{2}}{\delta}\\
y_i=\frac{y(p)+\frac{Y}{2}}{\delta}$$

$$S=S\cup\left(x_i,y_i\right)$$

## Lattice Planner Swaths

* Swath based methods are useful for lattice planners, as the swath sets can be computed offline
* Online collision checking is then simplified using lookup tables

### Speed and Robustness

* Need to improve speed
* Need to be robust to noise
* Use conservative approximations to solve both of these problems
* Want algorithmic speedup without sacrificing path quality

## Conservative Approximations

<img alt="Second state" src="./Conservative Circle Model.jpg" style="height:30vh;margin: 1em auto; display:block;"/>

* Conservative approximations may report a collision even if there isn't one, but will never miss a collision if it
were to actually happen
* The car can be completely encapsulated by three circles

## Circle Collision Checking

* Circle approximation is effective because it is fast to check if an occupancy grid point lies within a circle of radius $r$ centered at $(x_c,y_c)$
* If obstacle in occupancy grid lies within circle, a collision is reported
$$\lVert (x_i,y_i) -(x_c,y_c)\rVert \leq r$$
* Otherwise, due to conservative approximation, no collision is possible
$$\lVert (x_i,y_i) -(x_c,y_c)\rVert > r$$

## Discretization Resolution

* Collision checking accuracy is impacted by the resolution of our discretization
* Higher fidelity collision checking requires a finer resolution for occupancy grids and path points, and will require more computational resources
